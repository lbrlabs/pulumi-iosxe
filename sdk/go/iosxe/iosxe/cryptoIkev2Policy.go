// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iosxe

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-iosxe/sdk/go/iosxe/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

type CryptoIkev2Policy struct {
	pulumi.CustomResourceState

	// A device name from the provider configuration.
	Device pulumi.StringPtrOutput `pulumi:"device"`
	// Local address
	MatchAddressLocalIps pulumi.StringArrayOutput `pulumi:"matchAddressLocalIps"`
	MatchFvrf            pulumi.StringPtrOutput   `pulumi:"matchFvrf"`
	// Any fvrf
	MatchFvrfAny pulumi.BoolPtrOutput `pulumi:"matchFvrfAny"`
	// inbound only for controller
	MatchInboundOnly pulumi.BoolPtrOutput `pulumi:"matchInboundOnly"`
	Name             pulumi.StringOutput  `pulumi:"name"`
	// Specify Proposal
	Proposals CryptoIkev2PolicyProposalArrayOutput `pulumi:"proposals"`
}

// NewCryptoIkev2Policy registers a new resource with the given unique name, arguments, and options.
func NewCryptoIkev2Policy(ctx *pulumi.Context,
	name string, args *CryptoIkev2PolicyArgs, opts ...pulumi.ResourceOption) (*CryptoIkev2Policy, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Proposals == nil {
		return nil, errors.New("invalid value for required argument 'Proposals'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CryptoIkev2Policy
	err := ctx.RegisterResource("iosxe:iosxe/cryptoIkev2Policy:CryptoIkev2Policy", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCryptoIkev2Policy gets an existing CryptoIkev2Policy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCryptoIkev2Policy(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CryptoIkev2PolicyState, opts ...pulumi.ResourceOption) (*CryptoIkev2Policy, error) {
	var resource CryptoIkev2Policy
	err := ctx.ReadResource("iosxe:iosxe/cryptoIkev2Policy:CryptoIkev2Policy", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CryptoIkev2Policy resources.
type cryptoIkev2PolicyState struct {
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Local address
	MatchAddressLocalIps []string `pulumi:"matchAddressLocalIps"`
	MatchFvrf            *string  `pulumi:"matchFvrf"`
	// Any fvrf
	MatchFvrfAny *bool `pulumi:"matchFvrfAny"`
	// inbound only for controller
	MatchInboundOnly *bool   `pulumi:"matchInboundOnly"`
	Name             *string `pulumi:"name"`
	// Specify Proposal
	Proposals []CryptoIkev2PolicyProposal `pulumi:"proposals"`
}

type CryptoIkev2PolicyState struct {
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Local address
	MatchAddressLocalIps pulumi.StringArrayInput
	MatchFvrf            pulumi.StringPtrInput
	// Any fvrf
	MatchFvrfAny pulumi.BoolPtrInput
	// inbound only for controller
	MatchInboundOnly pulumi.BoolPtrInput
	Name             pulumi.StringPtrInput
	// Specify Proposal
	Proposals CryptoIkev2PolicyProposalArrayInput
}

func (CryptoIkev2PolicyState) ElementType() reflect.Type {
	return reflect.TypeOf((*cryptoIkev2PolicyState)(nil)).Elem()
}

type cryptoIkev2PolicyArgs struct {
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Local address
	MatchAddressLocalIps []string `pulumi:"matchAddressLocalIps"`
	MatchFvrf            *string  `pulumi:"matchFvrf"`
	// Any fvrf
	MatchFvrfAny *bool `pulumi:"matchFvrfAny"`
	// inbound only for controller
	MatchInboundOnly *bool   `pulumi:"matchInboundOnly"`
	Name             *string `pulumi:"name"`
	// Specify Proposal
	Proposals []CryptoIkev2PolicyProposal `pulumi:"proposals"`
}

// The set of arguments for constructing a CryptoIkev2Policy resource.
type CryptoIkev2PolicyArgs struct {
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Local address
	MatchAddressLocalIps pulumi.StringArrayInput
	MatchFvrf            pulumi.StringPtrInput
	// Any fvrf
	MatchFvrfAny pulumi.BoolPtrInput
	// inbound only for controller
	MatchInboundOnly pulumi.BoolPtrInput
	Name             pulumi.StringPtrInput
	// Specify Proposal
	Proposals CryptoIkev2PolicyProposalArrayInput
}

func (CryptoIkev2PolicyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cryptoIkev2PolicyArgs)(nil)).Elem()
}

type CryptoIkev2PolicyInput interface {
	pulumi.Input

	ToCryptoIkev2PolicyOutput() CryptoIkev2PolicyOutput
	ToCryptoIkev2PolicyOutputWithContext(ctx context.Context) CryptoIkev2PolicyOutput
}

func (*CryptoIkev2Policy) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoIkev2Policy)(nil)).Elem()
}

func (i *CryptoIkev2Policy) ToCryptoIkev2PolicyOutput() CryptoIkev2PolicyOutput {
	return i.ToCryptoIkev2PolicyOutputWithContext(context.Background())
}

func (i *CryptoIkev2Policy) ToCryptoIkev2PolicyOutputWithContext(ctx context.Context) CryptoIkev2PolicyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoIkev2PolicyOutput)
}

func (i *CryptoIkev2Policy) ToOutput(ctx context.Context) pulumix.Output[*CryptoIkev2Policy] {
	return pulumix.Output[*CryptoIkev2Policy]{
		OutputState: i.ToCryptoIkev2PolicyOutputWithContext(ctx).OutputState,
	}
}

// CryptoIkev2PolicyArrayInput is an input type that accepts CryptoIkev2PolicyArray and CryptoIkev2PolicyArrayOutput values.
// You can construct a concrete instance of `CryptoIkev2PolicyArrayInput` via:
//
//	CryptoIkev2PolicyArray{ CryptoIkev2PolicyArgs{...} }
type CryptoIkev2PolicyArrayInput interface {
	pulumi.Input

	ToCryptoIkev2PolicyArrayOutput() CryptoIkev2PolicyArrayOutput
	ToCryptoIkev2PolicyArrayOutputWithContext(context.Context) CryptoIkev2PolicyArrayOutput
}

type CryptoIkev2PolicyArray []CryptoIkev2PolicyInput

func (CryptoIkev2PolicyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CryptoIkev2Policy)(nil)).Elem()
}

func (i CryptoIkev2PolicyArray) ToCryptoIkev2PolicyArrayOutput() CryptoIkev2PolicyArrayOutput {
	return i.ToCryptoIkev2PolicyArrayOutputWithContext(context.Background())
}

func (i CryptoIkev2PolicyArray) ToCryptoIkev2PolicyArrayOutputWithContext(ctx context.Context) CryptoIkev2PolicyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoIkev2PolicyArrayOutput)
}

func (i CryptoIkev2PolicyArray) ToOutput(ctx context.Context) pulumix.Output[[]*CryptoIkev2Policy] {
	return pulumix.Output[[]*CryptoIkev2Policy]{
		OutputState: i.ToCryptoIkev2PolicyArrayOutputWithContext(ctx).OutputState,
	}
}

// CryptoIkev2PolicyMapInput is an input type that accepts CryptoIkev2PolicyMap and CryptoIkev2PolicyMapOutput values.
// You can construct a concrete instance of `CryptoIkev2PolicyMapInput` via:
//
//	CryptoIkev2PolicyMap{ "key": CryptoIkev2PolicyArgs{...} }
type CryptoIkev2PolicyMapInput interface {
	pulumi.Input

	ToCryptoIkev2PolicyMapOutput() CryptoIkev2PolicyMapOutput
	ToCryptoIkev2PolicyMapOutputWithContext(context.Context) CryptoIkev2PolicyMapOutput
}

type CryptoIkev2PolicyMap map[string]CryptoIkev2PolicyInput

func (CryptoIkev2PolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CryptoIkev2Policy)(nil)).Elem()
}

func (i CryptoIkev2PolicyMap) ToCryptoIkev2PolicyMapOutput() CryptoIkev2PolicyMapOutput {
	return i.ToCryptoIkev2PolicyMapOutputWithContext(context.Background())
}

func (i CryptoIkev2PolicyMap) ToCryptoIkev2PolicyMapOutputWithContext(ctx context.Context) CryptoIkev2PolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CryptoIkev2PolicyMapOutput)
}

func (i CryptoIkev2PolicyMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*CryptoIkev2Policy] {
	return pulumix.Output[map[string]*CryptoIkev2Policy]{
		OutputState: i.ToCryptoIkev2PolicyMapOutputWithContext(ctx).OutputState,
	}
}

type CryptoIkev2PolicyOutput struct{ *pulumi.OutputState }

func (CryptoIkev2PolicyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CryptoIkev2Policy)(nil)).Elem()
}

func (o CryptoIkev2PolicyOutput) ToCryptoIkev2PolicyOutput() CryptoIkev2PolicyOutput {
	return o
}

func (o CryptoIkev2PolicyOutput) ToCryptoIkev2PolicyOutputWithContext(ctx context.Context) CryptoIkev2PolicyOutput {
	return o
}

func (o CryptoIkev2PolicyOutput) ToOutput(ctx context.Context) pulumix.Output[*CryptoIkev2Policy] {
	return pulumix.Output[*CryptoIkev2Policy]{
		OutputState: o.OutputState,
	}
}

// A device name from the provider configuration.
func (o CryptoIkev2PolicyOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.StringPtrOutput { return v.Device }).(pulumi.StringPtrOutput)
}

// Local address
func (o CryptoIkev2PolicyOutput) MatchAddressLocalIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.StringArrayOutput { return v.MatchAddressLocalIps }).(pulumi.StringArrayOutput)
}

func (o CryptoIkev2PolicyOutput) MatchFvrf() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.StringPtrOutput { return v.MatchFvrf }).(pulumi.StringPtrOutput)
}

// Any fvrf
func (o CryptoIkev2PolicyOutput) MatchFvrfAny() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.BoolPtrOutput { return v.MatchFvrfAny }).(pulumi.BoolPtrOutput)
}

// inbound only for controller
func (o CryptoIkev2PolicyOutput) MatchInboundOnly() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.BoolPtrOutput { return v.MatchInboundOnly }).(pulumi.BoolPtrOutput)
}

func (o CryptoIkev2PolicyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Specify Proposal
func (o CryptoIkev2PolicyOutput) Proposals() CryptoIkev2PolicyProposalArrayOutput {
	return o.ApplyT(func(v *CryptoIkev2Policy) CryptoIkev2PolicyProposalArrayOutput { return v.Proposals }).(CryptoIkev2PolicyProposalArrayOutput)
}

type CryptoIkev2PolicyArrayOutput struct{ *pulumi.OutputState }

func (CryptoIkev2PolicyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CryptoIkev2Policy)(nil)).Elem()
}

func (o CryptoIkev2PolicyArrayOutput) ToCryptoIkev2PolicyArrayOutput() CryptoIkev2PolicyArrayOutput {
	return o
}

func (o CryptoIkev2PolicyArrayOutput) ToCryptoIkev2PolicyArrayOutputWithContext(ctx context.Context) CryptoIkev2PolicyArrayOutput {
	return o
}

func (o CryptoIkev2PolicyArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*CryptoIkev2Policy] {
	return pulumix.Output[[]*CryptoIkev2Policy]{
		OutputState: o.OutputState,
	}
}

func (o CryptoIkev2PolicyArrayOutput) Index(i pulumi.IntInput) CryptoIkev2PolicyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CryptoIkev2Policy {
		return vs[0].([]*CryptoIkev2Policy)[vs[1].(int)]
	}).(CryptoIkev2PolicyOutput)
}

type CryptoIkev2PolicyMapOutput struct{ *pulumi.OutputState }

func (CryptoIkev2PolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CryptoIkev2Policy)(nil)).Elem()
}

func (o CryptoIkev2PolicyMapOutput) ToCryptoIkev2PolicyMapOutput() CryptoIkev2PolicyMapOutput {
	return o
}

func (o CryptoIkev2PolicyMapOutput) ToCryptoIkev2PolicyMapOutputWithContext(ctx context.Context) CryptoIkev2PolicyMapOutput {
	return o
}

func (o CryptoIkev2PolicyMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*CryptoIkev2Policy] {
	return pulumix.Output[map[string]*CryptoIkev2Policy]{
		OutputState: o.OutputState,
	}
}

func (o CryptoIkev2PolicyMapOutput) MapIndex(k pulumi.StringInput) CryptoIkev2PolicyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CryptoIkev2Policy {
		return vs[0].(map[string]*CryptoIkev2Policy)[vs[1].(string)]
	}).(CryptoIkev2PolicyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoIkev2PolicyInput)(nil)).Elem(), &CryptoIkev2Policy{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoIkev2PolicyArrayInput)(nil)).Elem(), CryptoIkev2PolicyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CryptoIkev2PolicyMapInput)(nil)).Elem(), CryptoIkev2PolicyMap{})
	pulumi.RegisterOutputType(CryptoIkev2PolicyOutput{})
	pulumi.RegisterOutputType(CryptoIkev2PolicyArrayOutput{})
	pulumi.RegisterOutputType(CryptoIkev2PolicyMapOutput{})
}
