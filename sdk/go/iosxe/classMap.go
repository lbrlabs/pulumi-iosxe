// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iosxe

import (
	"context"
	"reflect"

	"errors"
	"github.com/lbrlabs/pulumi-iosxe/sdk/go/iosxe/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// This resource can manage the Class Map configuration.
//
// ## Import
//
// ```sh
//
//	$ pulumi import iosxe:index/classMap:ClassMap example "Cisco-IOS-XE-native:native/policy/Cisco-IOS-XE-policy:class-map=CM1"
//
// ```
type ClassMap struct {
	pulumi.CustomResourceState

	// Class-Map description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// A device name from the provider configuration.
	Device pulumi.StringPtrOutput `pulumi:"device"`
	// match name of service template activated on session
	MatchActivatedServiceTemplates ClassMapMatchActivatedServiceTemplateArrayOutput `pulumi:"matchActivatedServiceTemplates"`
	// authorized
	MatchAuthorizationStatusAuthorized pulumi.BoolPtrOutput `pulumi:"matchAuthorizationStatusAuthorized"`
	// unauthorized
	MatchAuthorizationStatusUnauthorized pulumi.BoolPtrOutput `pulumi:"matchAuthorizationStatusUnauthorized"`
	// greater than
	MatchAuthorizingMethodPriorityGreaterThans pulumi.IntArrayOutput `pulumi:"matchAuthorizingMethodPriorityGreaterThans"`
	// dot1x
	MatchMethodDot1x pulumi.BoolPtrOutput `pulumi:"matchMethodDot1x"`
	// mab
	MatchMethodMab pulumi.BoolPtrOutput `pulumi:"matchMethodMab"`
	// aaa timeout type
	MatchResultTypeAaaTimeout pulumi.BoolPtrOutput `pulumi:"matchResultTypeAaaTimeout"`
	// agent not found type
	MatchResultTypeMethodDot1xAgentNotFound pulumi.BoolPtrOutput `pulumi:"matchResultTypeMethodDot1xAgentNotFound"`
	// failure type
	MatchResultTypeMethodDot1xAuthoritative pulumi.BoolPtrOutput `pulumi:"matchResultTypeMethodDot1xAuthoritative"`
	// method_timeout type
	MatchResultTypeMethodDot1xMethodTimeout pulumi.BoolPtrOutput `pulumi:"matchResultTypeMethodDot1xMethodTimeout"`
	// failure type
	MatchResultTypeMethodMabAuthoritative pulumi.BoolPtrOutput `pulumi:"matchResultTypeMethodMabAuthoritative"`
	// name of the class map
	Name pulumi.StringOutput `pulumi:"name"`
	// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
	Prematch pulumi.StringOutput `pulumi:"prematch"`
	// Domain name of the class map
	Subscriber pulumi.BoolPtrOutput `pulumi:"subscriber"`
	// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
	// `stack`, `traffic`
	Type pulumi.StringPtrOutput `pulumi:"type"`
}

// NewClassMap registers a new resource with the given unique name, arguments, and options.
func NewClassMap(ctx *pulumi.Context,
	name string, args *ClassMapArgs, opts ...pulumi.ResourceOption) (*ClassMap, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Prematch == nil {
		return nil, errors.New("invalid value for required argument 'Prematch'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ClassMap
	err := ctx.RegisterResource("iosxe:index/classMap:ClassMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetClassMap gets an existing ClassMap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetClassMap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ClassMapState, opts ...pulumi.ResourceOption) (*ClassMap, error) {
	var resource ClassMap
	err := ctx.ReadResource("iosxe:index/classMap:ClassMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ClassMap resources.
type classMapState struct {
	// Class-Map description
	Description *string `pulumi:"description"`
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// match name of service template activated on session
	MatchActivatedServiceTemplates []ClassMapMatchActivatedServiceTemplate `pulumi:"matchActivatedServiceTemplates"`
	// authorized
	MatchAuthorizationStatusAuthorized *bool `pulumi:"matchAuthorizationStatusAuthorized"`
	// unauthorized
	MatchAuthorizationStatusUnauthorized *bool `pulumi:"matchAuthorizationStatusUnauthorized"`
	// greater than
	MatchAuthorizingMethodPriorityGreaterThans []int `pulumi:"matchAuthorizingMethodPriorityGreaterThans"`
	// dot1x
	MatchMethodDot1x *bool `pulumi:"matchMethodDot1x"`
	// mab
	MatchMethodMab *bool `pulumi:"matchMethodMab"`
	// aaa timeout type
	MatchResultTypeAaaTimeout *bool `pulumi:"matchResultTypeAaaTimeout"`
	// agent not found type
	MatchResultTypeMethodDot1xAgentNotFound *bool `pulumi:"matchResultTypeMethodDot1xAgentNotFound"`
	// failure type
	MatchResultTypeMethodDot1xAuthoritative *bool `pulumi:"matchResultTypeMethodDot1xAuthoritative"`
	// method_timeout type
	MatchResultTypeMethodDot1xMethodTimeout *bool `pulumi:"matchResultTypeMethodDot1xMethodTimeout"`
	// failure type
	MatchResultTypeMethodMabAuthoritative *bool `pulumi:"matchResultTypeMethodMabAuthoritative"`
	// name of the class map
	Name *string `pulumi:"name"`
	// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
	Prematch *string `pulumi:"prematch"`
	// Domain name of the class map
	Subscriber *bool `pulumi:"subscriber"`
	// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
	// `stack`, `traffic`
	Type *string `pulumi:"type"`
}

type ClassMapState struct {
	// Class-Map description
	Description pulumi.StringPtrInput
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// match name of service template activated on session
	MatchActivatedServiceTemplates ClassMapMatchActivatedServiceTemplateArrayInput
	// authorized
	MatchAuthorizationStatusAuthorized pulumi.BoolPtrInput
	// unauthorized
	MatchAuthorizationStatusUnauthorized pulumi.BoolPtrInput
	// greater than
	MatchAuthorizingMethodPriorityGreaterThans pulumi.IntArrayInput
	// dot1x
	MatchMethodDot1x pulumi.BoolPtrInput
	// mab
	MatchMethodMab pulumi.BoolPtrInput
	// aaa timeout type
	MatchResultTypeAaaTimeout pulumi.BoolPtrInput
	// agent not found type
	MatchResultTypeMethodDot1xAgentNotFound pulumi.BoolPtrInput
	// failure type
	MatchResultTypeMethodDot1xAuthoritative pulumi.BoolPtrInput
	// method_timeout type
	MatchResultTypeMethodDot1xMethodTimeout pulumi.BoolPtrInput
	// failure type
	MatchResultTypeMethodMabAuthoritative pulumi.BoolPtrInput
	// name of the class map
	Name pulumi.StringPtrInput
	// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
	Prematch pulumi.StringPtrInput
	// Domain name of the class map
	Subscriber pulumi.BoolPtrInput
	// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
	// `stack`, `traffic`
	Type pulumi.StringPtrInput
}

func (ClassMapState) ElementType() reflect.Type {
	return reflect.TypeOf((*classMapState)(nil)).Elem()
}

type classMapArgs struct {
	// Class-Map description
	Description *string `pulumi:"description"`
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// match name of service template activated on session
	MatchActivatedServiceTemplates []ClassMapMatchActivatedServiceTemplate `pulumi:"matchActivatedServiceTemplates"`
	// authorized
	MatchAuthorizationStatusAuthorized *bool `pulumi:"matchAuthorizationStatusAuthorized"`
	// unauthorized
	MatchAuthorizationStatusUnauthorized *bool `pulumi:"matchAuthorizationStatusUnauthorized"`
	// greater than
	MatchAuthorizingMethodPriorityGreaterThans []int `pulumi:"matchAuthorizingMethodPriorityGreaterThans"`
	// dot1x
	MatchMethodDot1x *bool `pulumi:"matchMethodDot1x"`
	// mab
	MatchMethodMab *bool `pulumi:"matchMethodMab"`
	// aaa timeout type
	MatchResultTypeAaaTimeout *bool `pulumi:"matchResultTypeAaaTimeout"`
	// agent not found type
	MatchResultTypeMethodDot1xAgentNotFound *bool `pulumi:"matchResultTypeMethodDot1xAgentNotFound"`
	// failure type
	MatchResultTypeMethodDot1xAuthoritative *bool `pulumi:"matchResultTypeMethodDot1xAuthoritative"`
	// method_timeout type
	MatchResultTypeMethodDot1xMethodTimeout *bool `pulumi:"matchResultTypeMethodDot1xMethodTimeout"`
	// failure type
	MatchResultTypeMethodMabAuthoritative *bool `pulumi:"matchResultTypeMethodMabAuthoritative"`
	// name of the class map
	Name *string `pulumi:"name"`
	// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
	Prematch string `pulumi:"prematch"`
	// Domain name of the class map
	Subscriber *bool `pulumi:"subscriber"`
	// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
	// `stack`, `traffic`
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a ClassMap resource.
type ClassMapArgs struct {
	// Class-Map description
	Description pulumi.StringPtrInput
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// match name of service template activated on session
	MatchActivatedServiceTemplates ClassMapMatchActivatedServiceTemplateArrayInput
	// authorized
	MatchAuthorizationStatusAuthorized pulumi.BoolPtrInput
	// unauthorized
	MatchAuthorizationStatusUnauthorized pulumi.BoolPtrInput
	// greater than
	MatchAuthorizingMethodPriorityGreaterThans pulumi.IntArrayInput
	// dot1x
	MatchMethodDot1x pulumi.BoolPtrInput
	// mab
	MatchMethodMab pulumi.BoolPtrInput
	// aaa timeout type
	MatchResultTypeAaaTimeout pulumi.BoolPtrInput
	// agent not found type
	MatchResultTypeMethodDot1xAgentNotFound pulumi.BoolPtrInput
	// failure type
	MatchResultTypeMethodDot1xAuthoritative pulumi.BoolPtrInput
	// method_timeout type
	MatchResultTypeMethodDot1xMethodTimeout pulumi.BoolPtrInput
	// failure type
	MatchResultTypeMethodMabAuthoritative pulumi.BoolPtrInput
	// name of the class map
	Name pulumi.StringPtrInput
	// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
	Prematch pulumi.StringInput
	// Domain name of the class map
	Subscriber pulumi.BoolPtrInput
	// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
	// `stack`, `traffic`
	Type pulumi.StringPtrInput
}

func (ClassMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*classMapArgs)(nil)).Elem()
}

type ClassMapInput interface {
	pulumi.Input

	ToClassMapOutput() ClassMapOutput
	ToClassMapOutputWithContext(ctx context.Context) ClassMapOutput
}

func (*ClassMap) ElementType() reflect.Type {
	return reflect.TypeOf((**ClassMap)(nil)).Elem()
}

func (i *ClassMap) ToClassMapOutput() ClassMapOutput {
	return i.ToClassMapOutputWithContext(context.Background())
}

func (i *ClassMap) ToClassMapOutputWithContext(ctx context.Context) ClassMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassMapOutput)
}

func (i *ClassMap) ToOutput(ctx context.Context) pulumix.Output[*ClassMap] {
	return pulumix.Output[*ClassMap]{
		OutputState: i.ToClassMapOutputWithContext(ctx).OutputState,
	}
}

// ClassMapArrayInput is an input type that accepts ClassMapArray and ClassMapArrayOutput values.
// You can construct a concrete instance of `ClassMapArrayInput` via:
//
//	ClassMapArray{ ClassMapArgs{...} }
type ClassMapArrayInput interface {
	pulumi.Input

	ToClassMapArrayOutput() ClassMapArrayOutput
	ToClassMapArrayOutputWithContext(context.Context) ClassMapArrayOutput
}

type ClassMapArray []ClassMapInput

func (ClassMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClassMap)(nil)).Elem()
}

func (i ClassMapArray) ToClassMapArrayOutput() ClassMapArrayOutput {
	return i.ToClassMapArrayOutputWithContext(context.Background())
}

func (i ClassMapArray) ToClassMapArrayOutputWithContext(ctx context.Context) ClassMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassMapArrayOutput)
}

func (i ClassMapArray) ToOutput(ctx context.Context) pulumix.Output[[]*ClassMap] {
	return pulumix.Output[[]*ClassMap]{
		OutputState: i.ToClassMapArrayOutputWithContext(ctx).OutputState,
	}
}

// ClassMapMapInput is an input type that accepts ClassMapMap and ClassMapMapOutput values.
// You can construct a concrete instance of `ClassMapMapInput` via:
//
//	ClassMapMap{ "key": ClassMapArgs{...} }
type ClassMapMapInput interface {
	pulumi.Input

	ToClassMapMapOutput() ClassMapMapOutput
	ToClassMapMapOutputWithContext(context.Context) ClassMapMapOutput
}

type ClassMapMap map[string]ClassMapInput

func (ClassMapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClassMap)(nil)).Elem()
}

func (i ClassMapMap) ToClassMapMapOutput() ClassMapMapOutput {
	return i.ToClassMapMapOutputWithContext(context.Background())
}

func (i ClassMapMap) ToClassMapMapOutputWithContext(ctx context.Context) ClassMapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ClassMapMapOutput)
}

func (i ClassMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*ClassMap] {
	return pulumix.Output[map[string]*ClassMap]{
		OutputState: i.ToClassMapMapOutputWithContext(ctx).OutputState,
	}
}

type ClassMapOutput struct{ *pulumi.OutputState }

func (ClassMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ClassMap)(nil)).Elem()
}

func (o ClassMapOutput) ToClassMapOutput() ClassMapOutput {
	return o
}

func (o ClassMapOutput) ToClassMapOutputWithContext(ctx context.Context) ClassMapOutput {
	return o
}

func (o ClassMapOutput) ToOutput(ctx context.Context) pulumix.Output[*ClassMap] {
	return pulumix.Output[*ClassMap]{
		OutputState: o.OutputState,
	}
}

// Class-Map description
func (o ClassMapOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// A device name from the provider configuration.
func (o ClassMapOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.StringPtrOutput { return v.Device }).(pulumi.StringPtrOutput)
}

// match name of service template activated on session
func (o ClassMapOutput) MatchActivatedServiceTemplates() ClassMapMatchActivatedServiceTemplateArrayOutput {
	return o.ApplyT(func(v *ClassMap) ClassMapMatchActivatedServiceTemplateArrayOutput {
		return v.MatchActivatedServiceTemplates
	}).(ClassMapMatchActivatedServiceTemplateArrayOutput)
}

// authorized
func (o ClassMapOutput) MatchAuthorizationStatusAuthorized() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchAuthorizationStatusAuthorized }).(pulumi.BoolPtrOutput)
}

// unauthorized
func (o ClassMapOutput) MatchAuthorizationStatusUnauthorized() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchAuthorizationStatusUnauthorized }).(pulumi.BoolPtrOutput)
}

// greater than
func (o ClassMapOutput) MatchAuthorizingMethodPriorityGreaterThans() pulumi.IntArrayOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.IntArrayOutput { return v.MatchAuthorizingMethodPriorityGreaterThans }).(pulumi.IntArrayOutput)
}

// dot1x
func (o ClassMapOutput) MatchMethodDot1x() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchMethodDot1x }).(pulumi.BoolPtrOutput)
}

// mab
func (o ClassMapOutput) MatchMethodMab() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchMethodMab }).(pulumi.BoolPtrOutput)
}

// aaa timeout type
func (o ClassMapOutput) MatchResultTypeAaaTimeout() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchResultTypeAaaTimeout }).(pulumi.BoolPtrOutput)
}

// agent not found type
func (o ClassMapOutput) MatchResultTypeMethodDot1xAgentNotFound() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchResultTypeMethodDot1xAgentNotFound }).(pulumi.BoolPtrOutput)
}

// failure type
func (o ClassMapOutput) MatchResultTypeMethodDot1xAuthoritative() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchResultTypeMethodDot1xAuthoritative }).(pulumi.BoolPtrOutput)
}

// method_timeout type
func (o ClassMapOutput) MatchResultTypeMethodDot1xMethodTimeout() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchResultTypeMethodDot1xMethodTimeout }).(pulumi.BoolPtrOutput)
}

// failure type
func (o ClassMapOutput) MatchResultTypeMethodMabAuthoritative() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.MatchResultTypeMethodMabAuthoritative }).(pulumi.BoolPtrOutput)
}

// name of the class map
func (o ClassMapOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Logical-AND/Logical-OR of all matching statements under this class map - Choices: `match-all`, `match-any`, `match-none`
func (o ClassMapOutput) Prematch() pulumi.StringOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.StringOutput { return v.Prematch }).(pulumi.StringOutput)
}

// Domain name of the class map
func (o ClassMapOutput) Subscriber() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.BoolPtrOutput { return v.Subscriber }).(pulumi.BoolPtrOutput)
}

// type of the class-map - Choices: `access-control`, `appnav`, `control`, `inspect`, `multicast-flows`, `site-manager`,
// `stack`, `traffic`
func (o ClassMapOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ClassMap) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

type ClassMapArrayOutput struct{ *pulumi.OutputState }

func (ClassMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ClassMap)(nil)).Elem()
}

func (o ClassMapArrayOutput) ToClassMapArrayOutput() ClassMapArrayOutput {
	return o
}

func (o ClassMapArrayOutput) ToClassMapArrayOutputWithContext(ctx context.Context) ClassMapArrayOutput {
	return o
}

func (o ClassMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*ClassMap] {
	return pulumix.Output[[]*ClassMap]{
		OutputState: o.OutputState,
	}
}

func (o ClassMapArrayOutput) Index(i pulumi.IntInput) ClassMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ClassMap {
		return vs[0].([]*ClassMap)[vs[1].(int)]
	}).(ClassMapOutput)
}

type ClassMapMapOutput struct{ *pulumi.OutputState }

func (ClassMapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ClassMap)(nil)).Elem()
}

func (o ClassMapMapOutput) ToClassMapMapOutput() ClassMapMapOutput {
	return o
}

func (o ClassMapMapOutput) ToClassMapMapOutputWithContext(ctx context.Context) ClassMapMapOutput {
	return o
}

func (o ClassMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*ClassMap] {
	return pulumix.Output[map[string]*ClassMap]{
		OutputState: o.OutputState,
	}
}

func (o ClassMapMapOutput) MapIndex(k pulumi.StringInput) ClassMapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ClassMap {
		return vs[0].(map[string]*ClassMap)[vs[1].(string)]
	}).(ClassMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ClassMapInput)(nil)).Elem(), &ClassMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClassMapArrayInput)(nil)).Elem(), ClassMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ClassMapMapInput)(nil)).Elem(), ClassMapMap{})
	pulumi.RegisterOutputType(ClassMapOutput{})
	pulumi.RegisterOutputType(ClassMapArrayOutput{})
	pulumi.RegisterOutputType(ClassMapMapOutput{})
}
