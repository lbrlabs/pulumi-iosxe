// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iosxe

import (
	"context"
	"reflect"

	"github.com/lbrlabs/pulumi-iosxe/sdk/go/iosxe/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// This resource can manage the Policy Map configuration.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/lbrlabs/pulumi-iosxe/sdk/go/iosxe"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := iosxe.NewPolicyMap(ctx, "example", &iosxe.PolicyMapArgs{
//				Subscriber: pulumi.Bool(true),
//				Type:       pulumi.String("control"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import iosxe:index/policyMap:PolicyMap example "Cisco-IOS-XE-native:native/policy/Cisco-IOS-XE-policy:policy-map=dot1x_policy"
//
// ```
type PolicyMap struct {
	pulumi.CustomResourceState

	// A device name from the provider configuration.
	Device pulumi.StringPtrOutput `pulumi:"device"`
	// Name of the policy map
	Name pulumi.StringOutput `pulumi:"name"`
	// Domain name of the policy map
	Subscriber pulumi.BoolPtrOutput `pulumi:"subscriber"`
	// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
	// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
	Type pulumi.StringPtrOutput `pulumi:"type"`
}

// NewPolicyMap registers a new resource with the given unique name, arguments, and options.
func NewPolicyMap(ctx *pulumi.Context,
	name string, args *PolicyMapArgs, opts ...pulumi.ResourceOption) (*PolicyMap, error) {
	if args == nil {
		args = &PolicyMapArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PolicyMap
	err := ctx.RegisterResource("iosxe:index/policyMap:PolicyMap", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPolicyMap gets an existing PolicyMap resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPolicyMap(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PolicyMapState, opts ...pulumi.ResourceOption) (*PolicyMap, error) {
	var resource PolicyMap
	err := ctx.ReadResource("iosxe:index/policyMap:PolicyMap", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PolicyMap resources.
type policyMapState struct {
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Name of the policy map
	Name *string `pulumi:"name"`
	// Domain name of the policy map
	Subscriber *bool `pulumi:"subscriber"`
	// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
	// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
	Type *string `pulumi:"type"`
}

type PolicyMapState struct {
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Name of the policy map
	Name pulumi.StringPtrInput
	// Domain name of the policy map
	Subscriber pulumi.BoolPtrInput
	// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
	// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
	Type pulumi.StringPtrInput
}

func (PolicyMapState) ElementType() reflect.Type {
	return reflect.TypeOf((*policyMapState)(nil)).Elem()
}

type policyMapArgs struct {
	// A device name from the provider configuration.
	Device *string `pulumi:"device"`
	// Name of the policy map
	Name *string `pulumi:"name"`
	// Domain name of the policy map
	Subscriber *bool `pulumi:"subscriber"`
	// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
	// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
	Type *string `pulumi:"type"`
}

// The set of arguments for constructing a PolicyMap resource.
type PolicyMapArgs struct {
	// A device name from the provider configuration.
	Device pulumi.StringPtrInput
	// Name of the policy map
	Name pulumi.StringPtrInput
	// Domain name of the policy map
	Subscriber pulumi.BoolPtrInput
	// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
	// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
	Type pulumi.StringPtrInput
}

func (PolicyMapArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*policyMapArgs)(nil)).Elem()
}

type PolicyMapInput interface {
	pulumi.Input

	ToPolicyMapOutput() PolicyMapOutput
	ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput
}

func (*PolicyMap) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyMap)(nil)).Elem()
}

func (i *PolicyMap) ToPolicyMapOutput() PolicyMapOutput {
	return i.ToPolicyMapOutputWithContext(context.Background())
}

func (i *PolicyMap) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapOutput)
}

func (i *PolicyMap) ToOutput(ctx context.Context) pulumix.Output[*PolicyMap] {
	return pulumix.Output[*PolicyMap]{
		OutputState: i.ToPolicyMapOutputWithContext(ctx).OutputState,
	}
}

// PolicyMapArrayInput is an input type that accepts PolicyMapArray and PolicyMapArrayOutput values.
// You can construct a concrete instance of `PolicyMapArrayInput` via:
//
//	PolicyMapArray{ PolicyMapArgs{...} }
type PolicyMapArrayInput interface {
	pulumi.Input

	ToPolicyMapArrayOutput() PolicyMapArrayOutput
	ToPolicyMapArrayOutputWithContext(context.Context) PolicyMapArrayOutput
}

type PolicyMapArray []PolicyMapInput

func (PolicyMapArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyMap)(nil)).Elem()
}

func (i PolicyMapArray) ToPolicyMapArrayOutput() PolicyMapArrayOutput {
	return i.ToPolicyMapArrayOutputWithContext(context.Background())
}

func (i PolicyMapArray) ToPolicyMapArrayOutputWithContext(ctx context.Context) PolicyMapArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapArrayOutput)
}

func (i PolicyMapArray) ToOutput(ctx context.Context) pulumix.Output[[]*PolicyMap] {
	return pulumix.Output[[]*PolicyMap]{
		OutputState: i.ToPolicyMapArrayOutputWithContext(ctx).OutputState,
	}
}

// PolicyMapMapInput is an input type that accepts PolicyMapMap and PolicyMapMapOutput values.
// You can construct a concrete instance of `PolicyMapMapInput` via:
//
//	PolicyMapMap{ "key": PolicyMapArgs{...} }
type PolicyMapMapInput interface {
	pulumi.Input

	ToPolicyMapMapOutput() PolicyMapMapOutput
	ToPolicyMapMapOutputWithContext(context.Context) PolicyMapMapOutput
}

type PolicyMapMap map[string]PolicyMapInput

func (PolicyMapMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyMap)(nil)).Elem()
}

func (i PolicyMapMap) ToPolicyMapMapOutput() PolicyMapMapOutput {
	return i.ToPolicyMapMapOutputWithContext(context.Background())
}

func (i PolicyMapMap) ToPolicyMapMapOutputWithContext(ctx context.Context) PolicyMapMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PolicyMapMapOutput)
}

func (i PolicyMapMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*PolicyMap] {
	return pulumix.Output[map[string]*PolicyMap]{
		OutputState: i.ToPolicyMapMapOutputWithContext(ctx).OutputState,
	}
}

type PolicyMapOutput struct{ *pulumi.OutputState }

func (PolicyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PolicyMap)(nil)).Elem()
}

func (o PolicyMapOutput) ToPolicyMapOutput() PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) ToPolicyMapOutputWithContext(ctx context.Context) PolicyMapOutput {
	return o
}

func (o PolicyMapOutput) ToOutput(ctx context.Context) pulumix.Output[*PolicyMap] {
	return pulumix.Output[*PolicyMap]{
		OutputState: o.OutputState,
	}
}

// A device name from the provider configuration.
func (o PolicyMapOutput) Device() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyMap) pulumi.StringPtrOutput { return v.Device }).(pulumi.StringPtrOutput)
}

// Name of the policy map
func (o PolicyMapOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *PolicyMap) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Domain name of the policy map
func (o PolicyMapOutput) Subscriber() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *PolicyMap) pulumi.BoolPtrOutput { return v.Subscriber }).(pulumi.BoolPtrOutput)
}

// type of the policy-map - Choices: `access-control`, `appnav`, `control`, `epbr`, `inspect`, `packet-service`,
// `performance-monitor`, `queueing`, `service`, `service-chain`, `umbrella`
func (o PolicyMapOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PolicyMap) pulumi.StringPtrOutput { return v.Type }).(pulumi.StringPtrOutput)
}

type PolicyMapArrayOutput struct{ *pulumi.OutputState }

func (PolicyMapArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PolicyMap)(nil)).Elem()
}

func (o PolicyMapArrayOutput) ToPolicyMapArrayOutput() PolicyMapArrayOutput {
	return o
}

func (o PolicyMapArrayOutput) ToPolicyMapArrayOutputWithContext(ctx context.Context) PolicyMapArrayOutput {
	return o
}

func (o PolicyMapArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*PolicyMap] {
	return pulumix.Output[[]*PolicyMap]{
		OutputState: o.OutputState,
	}
}

func (o PolicyMapArrayOutput) Index(i pulumi.IntInput) PolicyMapOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PolicyMap {
		return vs[0].([]*PolicyMap)[vs[1].(int)]
	}).(PolicyMapOutput)
}

type PolicyMapMapOutput struct{ *pulumi.OutputState }

func (PolicyMapMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PolicyMap)(nil)).Elem()
}

func (o PolicyMapMapOutput) ToPolicyMapMapOutput() PolicyMapMapOutput {
	return o
}

func (o PolicyMapMapOutput) ToPolicyMapMapOutputWithContext(ctx context.Context) PolicyMapMapOutput {
	return o
}

func (o PolicyMapMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*PolicyMap] {
	return pulumix.Output[map[string]*PolicyMap]{
		OutputState: o.OutputState,
	}
}

func (o PolicyMapMapOutput) MapIndex(k pulumi.StringInput) PolicyMapOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PolicyMap {
		return vs[0].(map[string]*PolicyMap)[vs[1].(string)]
	}).(PolicyMapOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapInput)(nil)).Elem(), &PolicyMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapArrayInput)(nil)).Elem(), PolicyMapArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PolicyMapMapInput)(nil)).Elem(), PolicyMapMap{})
	pulumi.RegisterOutputType(PolicyMapOutput{})
	pulumi.RegisterOutputType(PolicyMapArrayOutput{})
	pulumi.RegisterOutputType(PolicyMapMapOutput{})
}
